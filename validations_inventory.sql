-- =====================================================
-- VALIDAÇÕES PARA FACT_INVENTORY
-- =====================================================

USE SCHEMA DWH;

-- =====================================================
-- 1. VALIDAÇÕES DE INTEGRIDADE REFERENCIAL
-- =====================================================

-- Verificar registros órfãos em WAREHOUSE
SELECT 'WAREHOUSE_ORPHANS' AS VALIDATION, COUNT(*) AS ISSUES
FROM FACT_INVENTORY fi
LEFT JOIN DIM_WAREHOUSE dw ON dw.WAREHOUSE_SK = fi.WAREHOUSE_SK
WHERE dw.WAREHOUSE_SK IS NULL;

-- Verificar registros órfãos em PRODUCT
SELECT 'PRODUCT_ORPHANS' AS VALIDATION, COUNT(*) AS ISSUES
FROM FACT_INVENTORY fi
LEFT JOIN DIM_PRODUCT dp ON dp.PRODUCT_SK = fi.PRODUCT_SK
WHERE dp.PRODUCT_SK IS NULL;

-- Verificar registros órfãos em MOVEMENT_TYPE
SELECT 'MOVEMENT_TYPE_ORPHANS' AS VALIDATION, COUNT(*) AS ISSUES
FROM FACT_INVENTORY fi
LEFT JOIN DIM_MOVEMENT_TYPE dmt ON dmt.MOVEMENT_TYPE_SK = fi.MOVEMENT_TYPE_SK
WHERE dmt.MOVEMENT_TYPE_SK IS NULL;

-- Verificar registros órfãos em DATE
SELECT 'DATE_ORPHANS' AS VALIDATION, COUNT(*) AS ISSUES
FROM FACT_INVENTORY fi
LEFT JOIN DIM_DATE dd ON dd.DATE_KEY = fi.DATE_KEY
WHERE dd.DATE_KEY IS NULL;

-- =====================================================
-- 2. RECONCILIAÇÃO ENTRE STAGING E DWH
-- =====================================================

-- Verificar se todas as movimentações foram carregadas
SELECT 'MOVEMENT_COUNT_MATCH' AS VALIDATION, 
       ABS(STAGING_COUNT - DWH_COUNT) AS DIFFERENCE
FROM (
  SELECT 
    (SELECT COUNT(*) FROM STAGING.INVENTORY_MOVEMENTS) AS STAGING_COUNT,
    (SELECT COUNT(*) FROM FACT_INVENTORY) AS DWH_COUNT
);

-- Verificar se o total de valores batem
SELECT 'TOTAL_COST_MATCH' AS VALIDATION,
       ABS(STAGING_TOTAL - DWH_TOTAL) AS DIFFERENCE
FROM (
  SELECT 
    (SELECT SUM(QUANTITY * UNIT_COST) FROM STAGING.INVENTORY_MOVEMENTS) AS STAGING_TOTAL,
    (SELECT SUM(TOTAL_COST) FROM FACT_INVENTORY) AS DWH_TOTAL
);

-- =====================================================
-- 3. VALIDAÇÕES DE CONSISTÊNCIA DOS DADOS
-- =====================================================

-- Verificar se não há estoque negativo inconsistente
SELECT 'NEGATIVE_STOCK_ISSUES' AS VALIDATION, COUNT(*) AS ISSUES
FROM (
  SELECT 
    fi.WAREHOUSE_SK,
    fi.PRODUCT_SK,
    SUM(fi.QUANTITY_CHANGE) AS FINAL_STOCK
  FROM FACT_INVENTORY fi
  GROUP BY fi.WAREHOUSE_SK, fi.PRODUCT_SK
  HAVING SUM(fi.QUANTITY_CHANGE) < -10  -- Permitir pequenos negativos por ajustes
);

-- Verificar se custos unitários são razoáveis
SELECT 'UNREASONABLE_COSTS' AS VALIDATION, COUNT(*) AS ISSUES
FROM FACT_INVENTORY fi
WHERE fi.UNIT_COST <= 0 OR fi.UNIT_COST > 50000;

-- Verificar duplicatas no grain
SELECT 'DUPLICATE_GRAIN' AS VALIDATION, COUNT(*) AS ISSUES
FROM (
  SELECT DATE_KEY, WAREHOUSE_SK, PRODUCT_SK, MOVEMENT_ID
  FROM FACT_INVENTORY
  GROUP BY DATE_KEY, WAREHOUSE_SK, PRODUCT_SK, MOVEMENT_ID
  HAVING COUNT(*) > 1
);

-- =====================================================
-- 4. VALIDAÇÕES DE RUNNING BALANCE
-- =====================================================

-- Verificar se o running balance está sendo calculado corretamente
-- (comparar com recálculo)
WITH recalculated_balance AS (
  SELECT 
    fi.MOVEMENT_ID,
    fi.WAREHOUSE_SK,
    fi.PRODUCT_SK,
    fi.RUNNING_BALANCE AS STORED_BALANCE,
    SUM(fi2.QUANTITY_CHANGE) AS CALCULATED_BALANCE
  FROM FACT_INVENTORY fi
  JOIN FACT_INVENTORY fi2 ON fi2.WAREHOUSE_SK = fi.WAREHOUSE_SK 
                         AND fi2.PRODUCT_SK = fi.PRODUCT_SK
                         AND (fi2.MOVEMENT_TIMESTAMP <= fi.MOVEMENT_TIMESTAMP
                              OR (fi2.MOVEMENT_TIMESTAMP = fi.MOVEMENT_TIMESTAMP 
                                  AND fi2.MOVEMENT_ID <= fi.MOVEMENT_ID))
  GROUP BY fi.MOVEMENT_ID, fi.WAREHOUSE_SK, fi.PRODUCT_SK, fi.RUNNING_BALANCE
)
SELECT 'RUNNING_BALANCE_ERRORS' AS VALIDATION, COUNT(*) AS ISSUES
FROM recalculated_balance
WHERE ABS(STORED_BALANCE - CALCULATED_BALANCE) > 0;

-- =====================================================
-- 5. RELATÓRIOS DE VALIDAÇÃO RESUMIDOS
-- =====================================================

-- Resumo geral das validações
SELECT 'TOTAL_MOVEMENTS' AS METRIC, COUNT(*) AS VALUE FROM FACT_INVENTORY
UNION ALL
SELECT 'TOTAL_WAREHOUSES', COUNT(DISTINCT WAREHOUSE_SK) FROM FACT_INVENTORY
UNION ALL
SELECT 'TOTAL_PRODUCTS', COUNT(DISTINCT PRODUCT_SK) FROM FACT_INVENTORY
UNION ALL
SELECT 'TOTAL_SUPPLIERS', COUNT(DISTINCT SUPPLIER_SK) FROM FACT_INVENTORY WHERE SUPPLIER_SK <> -1
UNION ALL
SELECT 'DATE_RANGE_DAYS', DATEDIFF('day', MIN(MOVEMENT_TIMESTAMP), MAX(MOVEMENT_TIMESTAMP)) + 1 FROM FACT_INVENTORY
UNION ALL
SELECT 'TOTAL_VALUE', SUM(TOTAL_COST) FROM FACT_INVENTORY
ORDER BY METRIC;

-- Verificar distribuição por tipo de movimentação
SELECT 
  dmt.MOVEMENT_TYPE,
  dmt.MOVEMENT_CATEGORY,
  COUNT(*) AS MOVEMENT_COUNT,
  SUM(fi.QUANTITY_CHANGE) AS TOTAL_QUANTITY,
  SUM(fi.TOTAL_COST) AS TOTAL_VALUE
FROM FACT_INVENTORY fi
JOIN DIM_MOVEMENT_TYPE dmt ON dmt.MOVEMENT_TYPE_SK = fi.MOVEMENT_TYPE_SK
GROUP BY dmt.MOVEMENT_TYPE, dmt.MOVEMENT_CATEGORY
ORDER BY TOTAL_VALUE DESC;

-- Verificar estoque atual por warehouse
SELECT 
  dw.WAREHOUSE_NAME,
  dw.WAREHOUSE_TYPE,
  COUNT(DISTINCT dp.PRODUCT_SK) AS PRODUCTS_IN_STOCK,
  SUM(CASE WHEN current_stock.FINAL_STOCK > 0 THEN 1 ELSE 0 END) AS PRODUCTS_WITH_POSITIVE_STOCK,
  SUM(current_stock.FINAL_STOCK) AS TOTAL_UNITS,
  SUM(current_stock.FINAL_VALUE) AS TOTAL_VALUE
FROM DIM_WAREHOUSE dw
JOIN (
  SELECT 
    fi.WAREHOUSE_SK,
    fi.PRODUCT_SK,
    SUM(fi.QUANTITY_CHANGE) AS FINAL_STOCK,
    SUM(fi.QUANTITY_CHANGE) * AVG(fi.UNIT_COST) AS FINAL_VALUE
  FROM FACT_INVENTORY fi
  GROUP BY fi.WAREHOUSE_SK, fi.PRODUCT_SK
) current_stock ON current_stock.WAREHOUSE_SK = dw.WAREHOUSE_SK
JOIN DIM_PRODUCT dp ON dp.PRODUCT_SK = current_stock.PRODUCT_SK
GROUP BY dw.WAREHOUSE_SK, dw.WAREHOUSE_NAME, dw.WAREHOUSE_TYPE
ORDER BY TOTAL_VALUE DESC; 